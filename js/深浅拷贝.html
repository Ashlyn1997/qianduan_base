<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>深浅拷贝</title>
</head>
<body>
<script>
    //利用 = 赋值操作符实现了一个浅拷贝
    const originArray = [1,2,3,4,5]
    const originObj = {a: 'a', b: 'b', c: [1,2,3], d: {dd: 'dd'}}
    const cloneArray = originArray
    const cloneObj = originObj
    console.log(cloneArray) //[1,2,3,4,5]
    console.log(cloneObj) //{a: 'a', b: 'b', c: [1,2,3], d: {dd: 'dd'}}
    cloneArray.push(6)
    cloneObj.a = {aa: 'aa'}
    console.log(cloneArray) //[1,2,3,4,5,6]
    console.log(originArray) //[1,2,3,4,5,6]
    console.log(cloneObj) //a: {aa: 'aa'}, b: 'b', c: [1,2,3], d: {dd: 'dd'}}
    console.log(originObj) //a: {aa: 'aa'}, b: 'b', c: [1,2,3], d: {dd: 'dd'}}

    //深拷贝
    //目前实现深拷贝的方法不多，主要是两种：
    // 1. 利用JSON对象中的parse和stringify
    // 2. 利用递归来实现每一层都重新创建对象并赋值
    const originArray = [1,2,3,4,5]
    const cloneArray = JSON.parse(JSON.stringify(originArray))
    console.log(cloneArray === originArray) //false
    const originObj = {a: 'a', b: 'b', c: [1,2,3], d: {dd: 'dd'}}
    const cloneObj = JSON.parse(JSON.stringify(originObj))
    cloneObj.a = 'aa';
    cloneObj.c = [1,1,1];
    cloneObj.d.dd = 'doubled';
    console.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};
    console.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
    //确实是深拷贝，也很方便。但是，这个方法只能适用于一些简单的情况。比如下面这样的一个对象就不适用：
    const originObj = {
        name:'axuebin',
        sayHello:function(){
            console.log('Hello World');
        }
    }
    console.log(originObj); // {name: "axuebin", sayHello: ƒ}
    const cloneObj = JSON.parse(JSON.stringify(originObj));
    console.log(cloneObj); // {name: "axuebin"}
    //undefined、function、symbol 会在转换过程中被忽略。。。
    //明白了吧，就是说如果对象中含有一个函数时（很常见），就不能用这个方法进行深拷贝。
    //递归
    //就是对每一层的数据都实现一次 创建对象->对象赋值 的操作，简单粗暴上代码：
    function deepClone(source) {
        const targetObj = source.constructor === Array ? [] : {} //判断复制的目标是数组还是对象
        for(let keys in source) { //遍历目标
            if (source.hasOwnProperty(keys)) { // hasOwnProperty()用来检测一个对象是否有特定的自身属性
                if(source[keys] && typeof source[keys] === 'object'){ // 如果值是对象，就递归一下
                    targetObj[keys] = source[keys].constructor === Array ? [] : {};
                    targetObj[keys] = deepClone(source[keys]);
                }else{ // 如果不是，就直接赋值
                    targetObj[keys] = source[keys];
                }
            }
        }
        return targetObj;
    }
    const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}}
    const cloneObj = deepClone(originObj)
    console.log(cloneObj === originObj) // false
    cloneObj.a = 'aa';
    cloneObj.c = [1,1,1];
    cloneObj.d.dd = 'doubled';

    console.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};
    console.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
</script>
</body>
</html>